# 数据库索引与优化

索引是对数据库表中一列或多列的值进行排序的一种结构。MySQL索引的建立对于MySQL的高效运行是很重要的，索引可以大大提高MySQL的检索速度。索引只是提高效率的一个因素，如果你的MySQL有大数据量的表，就需要花时间研究建立最优秀的索引，或优化查询语句。

## 一、索引的优缺点

### 优点

- 索引大大减小了服务器需要扫描的数据量，从而大大加快数据的检索速度，这也是创建索引的最主要的原因。
- 索引可以帮助服务器避免排序和创建临时表。
- 索引可以将随机IO变成顺序IO。
- 索引对于InnoDB（对索引支持行级锁）非常重要，因为它可以让查询锁更少的元组，提高了表访问并发性。
- 通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。
- 可以加速表和表之间的连接，特别是在实现数据的参考完整性方面特别有意义。
- 在使用分组和排序子句进行数据检索时，同样可以显著减少查询中分组和排序的时间。
- 通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能。

### 缺点

- 创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加。
- 索引需要占物理空间，除了数据表占用数据空间之外，每一个索引还要占用一定的物理空间，如果需要建立聚簇索引，那么需要占用的空间会更大。
- 对表中的数据进行增、删、改的时候，索引也要动态的维护，这就降低了整数的维护速度。
- 如果某个数据列包含许多重复的内容，为它建立索引就没有太大的实际效果。
- 对于非常小的表，大部分情况下简单的全表扫描更高效。

## 二、创建索引准则

索引是建立在数据库表中的某些列的上面。因此，在创建索引的时候，应该仔细考虑在哪些列上可以创建索引，在哪些列上不能创建索引。

### 应该创建索引的列

- 在经常需要搜索的列上，可以加快搜索的速度。
- 在作为主键的列上，强制该列的唯一性和组织表中数据的排列结构。
- 在经常用在连接（JOIN）的列上，这些列主要是一外键，可以加快连接的速度。
- 在经常需要根据范围（<，<=，=，>，>=，BETWEEN，IN）进行搜索的列上创建索引，因为索引已经排序，其指定的范围是连续的。
- 在经常需要排序（order by）的列上创建索引，因为索引已经排序，这样查询可以利用索引的排序，加快排序查询时间。
- 在经常使用在WHERE子句中的列上面创建索引，加快条件的判断速度。

### 不该创建索引的列

- 对于那些在查询中很少使用或者参考的列不应该创建索引。
- 若列很少使用到，因此有索引或者无索引，并不能提高查询速度。相反，由于增加了索引，反而降低了系统的维护速度和增大了空间需求。
- 对于那些只有很少数据值或者重复值多的列也不应该增加索引。

## 三、MySQL索引结构与存储

MySQL中常用的索引结构（索引底层的数据结构）有：B-TREE，B+TREE，HASH 等。以下是对它们的简要说明：

## B-TREE

B-树（B-Tree）是一种多路搜索树，其特征包括：

- 关键字集合分布在整颗树中；
- 任何一个关键字出现且只出现在一个结点中；
- 搜索有可能在非叶子结点结束；
- 其搜索性能等价于在关键字全集内做一次二分查找；
- 自动层次控制。

## B+TREE

B+树（B+Tree）是B-树的变体，也是一种多路搜索树，其特征包括：

- 所有关键字都出现在叶子结点的链表中（稠密索引），且链表中的关键字恰好是有序的；
- 不可能在非叶子结点命中；
- 非叶子结点相当于是叶子结点的索引（稀疏索引），叶子结点相当于是存储（关键字）数据的数据层；
- 每一个叶子节点都包含指向下一个叶子节点的指针，从而方便叶子节点的范围遍历；
- 更适合文件索引系统。

## HASH

哈希索引（HASH）采用一定的哈希算法，把键值换算成新的哈希值，检索时不需要类似B+树那样从根节点到叶子节点逐级查找，只需一次哈希算法即可立刻定位到相应的位置，速度非常快。其特点包括：

- 仅仅能满足"="，“IN"和”<=>"查询，不能使用范围查询；
- 不能支持任何范围查询，例如WHERE price > 100；
- 索引存储在文件系统中。

## 索引存储在文件系统中

在不同的存储引擎中，索引存在的文件也不同。以下是两种常见存储引擎的索引文件：

### 存储引擎为MyISAM：

- *.frm：与表相关的元数据信息都存放在frm文件，包括表结构的定义信息等；
- *.MYD：MyISAM DATA，用于存储MyISAM表的数据；
- *.MYI：MyISAM INDEX，用于存储MyISAM表的索引相关信息。

### 存储引擎为InnoDB：

- *.frm：与表相关的元数据信息都存放在frm文件，包括表结构的定义信息等；
- *.ibd：InnoDB DATA，表数据和索引的文件。该表的索引（B+树）的每个非叶子节点存储索引，叶子节点存储索引和索引对应的数据。

## 四、MySQL索引分类与存储

MySQL的索引可以根据不同的分类方式进行划分，包括逻辑分类和物理分类。

### 逻辑分类

### 按功能划分

1. **主键索引**：一张表只能有一个主键索引，保证唯一性，不允许重复、不允许为NULL。
2. **唯一索引**：保证数据列的唯一性，允许NULL值，一张表可以有多个唯一索引。
3. **普通索引**：允许数据重复，允许NULL值插入，一张表可以创建多个普通索引。
4. **全文索引**：用于全文检索，查找文本中的关键词。

### 按列数划分

- **单列索引**：一个索引只包含一个列，一个表可以有多个单例索引。
- **组合索引**：包含两个或两个以上的列，查询时遵循“最左前缀”原则。

### 物理分类

### 聚簇索引和非聚簇索引

- **聚簇索引**：将索引和数据存储在一起，数据访问更快，主键索引通常是聚簇索引。
- **非聚簇索引**：数据和索引分开存储，B+树叶子节点存放的不是数据表的行记录。

### 索引存储在文件系统中

- **MyISAM引擎**：包含`.frm`、`.MYD`和`.MYI`文件。
- **InnoDB引擎**：包含`.frm`和`.ibd`文件。

## 五、InnoDB和MyISAM索引实现

在MySQL中，InnoDB和MyISAM是两种常见的存储引擎，它们的索引实现方式有所不同。

### InnoDB索引实现

InnoDB使用B+树作为索引结构，包括主键索引和辅助索引。

- **主键索引**：是一种聚簇索引，B+树的叶子节点包含了完整的数据记录，数据和索引存储在一起。
- **辅助索引**：是一种非聚簇索引，叶子节点存储的是主键值，需要通过主键索引树来找到对应的数据行。

InnoDB表的索引和数据存储在一起，聚簇索引的数据是按照主键的顺序存储的。

### MyISAM索引实现

MyISAM也使用B+树作为索引结构，但索引和数据是分开存储的。

- **主键索引**：非聚簇索引，叶子节点存储的是数据记录的地址。
- **辅助索引**：与主键索引结构相同，但索引的key可以重复。

MyISAM的辅助索引也是非聚簇索引，索引树与主键索引树是相互独立的。

### InnoDB和MyISAM的索引检索过程

- **InnoDB**：辅助索引的访问需要两次索引查找，第一次从辅助索引树找到主键值，第二次根据主键值到主键索引树中找到对应的行数据。
- **MyISAM**：主键索引和辅助索引的索引树是相互独立的，通过辅助索引检索无需访问主键索引树。

聚簇索引和非聚簇索引的区别在于叶子节点存储的内容不同，聚簇索引存储了完整的数据记录，而非聚簇索引存储的是主键值或数据记录的地址。
## 六、数据库索引操作指南

## 操作索引

### 创建索引

#### 创建普通索引 
CREATE INDEX index_name ON table_name(col_name);

#### 创建唯一索引
CREATE UNIQUE INDEX index_name ON table_name(col_name);

#### 创建普通组合索引
CREATE INDEX index_name ON table_name(col_name_1,col_name_2);

#### 创建唯一组合索引
CREATE UNIQUE INDEX index_name ON table_name(col_name_1,col_name_2);

### 修改表结构创建索引
ALTER TABLE table_name ADD INDEX index_name(col_name);

### 创建表时直接指定索引
CREATE TABLE table_name (
    ID INT NOT NULL,
    col_name VARCHAR (16) NOT NULL,
    INDEX index_name (col_name)
);

### 删除索引
-- 直接删除索引
DROP INDEX index_name ON table_name;

-- 修改表结构删除索引
ALTER TABLE table_name DROP INDEX index_name;

### 其它相关命令
-- 查看表结构
desc table_name;

-- 查看生成表的SQL
show create table table_name;

-- 查看索引信息（包括索引结构等）
show index from  table_name;

-- 查看SQL执行时间（精确到小数点后8位）
set profiling = 1;
SQL...
show profiles;
